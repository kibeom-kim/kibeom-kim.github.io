---
title: Real MySQL 8.0 1권 - 05 트랜잭션과 잠금
date: 2025-04-02
update: 2025-04-02
tags: 
    - mysql8.0
---

# 5 트랜잭션과 잠금
- 트랜잭션은 작업의 완전성을 보장해 주는 것.
- 잠금 lock은 동시성을 제어하기 위한 기능, 트랜잭션은 데이터의 정합성을 보장하기 위한 기능
- 격리수준은 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨을 의미

## 5.1 트랜잭션
- MyISAM, MEMORY 스토리지 엔진은 트랜잭션을 지원하지 않음 (InnoDB는 지원)

### 5.1.1 MySQL에서의 트랜잭션
- 예를 들어 트랜잭션을 지원하지 않는 스토리지 엔진에서 키 중복 오류로 쿼리가 실패하면 부분 업데이트 partial update 문제가 발생함
    - InnoDB 의 경우 원 상태로 복구됨 => 트랜잭션은 어플리케이션 개발에서 고민해야 할 문제를 줄여주는 필수적인 DBMS의 기능

### 5.1.2 주의사항
- 트랜잭션은 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. -> 트랜잭션의 범위를 최소화할 것.
    - 커넥션 수는 개수가 제한적어서 각 단위 프로그램이 커넥션을 소유하는 시간이 길어질수록 여유 커넥션 수는 줄어들 것.
- 메일 전송이나 ftp 파일 전송, 네트워크를 통한 원격 서버와 통신하는 등의 작업은 트랜잭션에서 제거할 것

## 5.2 MySQL 엔진의 잠금
- 크게 스토리지 엔진 레벨과 MySQL 엔진 레벨(스토리지 엔진 제외한 나머지 부분)로 나눌 수 있다.
- MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 줌, 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 영향은 없음
- MySQl 엔진에서는 테이블 데이터 동기화를 위한 데이블락, 테이블 구조를 잠그는 메타데이터락, 사용자의 필요에 맞게 사용할 수 있는 네이듬락이라는 기능도 제공

### 5.2.1 글로벌 락
- MySQL에서 제공하는 잠금 중 가장 범위가 넓음
- 다른 세션에서 select 를 제외한 대부분의 DDL, DML 문장을 실행하는 경우 글로벌 락이 해제될 때까지 해당 문장이 대기 상태로 남음
    - mysqldump와 같은 백업 툴에서는 내부적으로 실해앟고 백업할 때도 있으니 옵션을 확인해야 함
- InnoDB 엔진은 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요가 없음
    - 이로 인해 보다 가벼운 글로벌 락의 필요성이 생김
- MySQL 8.0 부터는 백업 툴들의 안정적 실행을 위해 백업 락이 도입. 모든 세션에서 테이블의 스키마나 사용자의 인증 관련 정보를 변경할 수 없게 됨
    - 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
    - REPAIR TABLE과 OPTIMIZE TABLE 명령
    - 사용자 관리 및 비밀번호 변경
    - 반대로 일반적인 테이블의 데이터 변경은 허용
- 백업 락의 도입 목적
    - 일반적으로 MySQL 서버의 구성은 소스 서버와 레플리카 서버로 구성됨
    - 글로벌 락을 획득하면 복제는 백업 시간만큼 지연
    - 백업 툴이 실행되는 도중 스키마 변경이 실해오디면 백업이 ㅅ ㅣㄹ패하게 됨. 6-7시간 백업하다가 DDL 명령 하나로 백업이 실패하면 시간을 또 써야 함
    - 정상적으로 복제는 실행되지만, 백업의 실패를 막기 위해 DDL 명령이 실행되면 복제를 일시 중지하는 역할을 함

### 5.2.2 테이블 락
- 개별 테이블 단위로 설정되는 잠금
- 명시적, 묵시적으로 잠금 설정이 가능하며 명시적으로 잠그는 작업은 글로벌 락과 동일하게 온라인 작업에 상당한 영향을 미치기 때문에 거의 사용할 필요가 없음
- 묵시적 락은 MyISAM, MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생
- InnoDB는 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에 단순 데이터 변경 쿼리로 인해 묵시적 테이블 락이 설정되지는 않음
    - 엄밀히는 테이블 락이 설정되지만 DML 쿼리에서는 무시되고, 스키마를 변경하는 DDL의 경우에만 영향을 미친다

### 5.2.3 네임드 락
- GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있음
    - 테이블, 레코드, autoincrement와 같은 DB 객체가 아닌 지정한 문자열에 대해 획득하고 반납하는 잠금
- 많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용할 수 있음
- MySQL 8.0에서는 네임드 락을 중첩으로 사용할 수 있게 되었으며, 세션의 네임드 락을 모두 해제하는 기능도 추가됨
```sql
select GET_LOCK('mylock_1', 10);
select GET_LOCK('mylock_2', 10);
select RELEASE_LOCK('mylock_2');  // 개별 해제
select RELEASE_ALL_LOCKS();  // 모두 해제
```

### 5.2.4 메타데이터 락
- 데이터베이스 객체의 이름이나 구조를 변경하는 경우 획득하는 잠금
- 명시적으로 획득하고 해제하는 것이 아니고 테이블 이름을 변경하는 경우 자동으로 획득(원본 이름, 변경된 이름 모두)
```sql
rename table rank to rank_backup, rank_new to rank;  // 정상    
rename table rank to rank_backup;  
raname table rank_new to rank; // 이렇게 나뉘는 경우 rank 테이블이 존재하지 않는 순간이 생김
```

활용 예시)
메타데이터 잠금 + 트랜잭션
insert만되는 로그 테이블에 구조 변경할 요건이 있음
online DDL - 언두 로그 증가와 버퍼 크기, MySQL 서버의 DDL은 단일 스레드라 시간이 오래 걸림.
-> 이따 먼저 새로운 구조의 테이블을 생성하고 여러 개의 스레드가 범위를 나누어서 데이터를 복사하도록 한다.
-> 완료된 후 나머지 기존 데이터를 옮기기 위해 양 테이블에 모두 write 를 제한
-> 최근 데이터까지 복사해둬야 잠금 시간이 최소화
-> write 가 워낙 많은 테이블이라면 가능할까?

## 5.3 InnoDB 스토리지 엔진 잠금
레코드 기반의 잠금 방식을 탑재, 이로 인해 MyISAM보다 훨씬 뛰어난 도이시성 처리를 제공
information_schema 데이터베이스에서 INNODB_TRX, INNODB_LOCKS, INNODB_WAITS 라는 테이블을 조인해서 어떤 트랜잭션이 어떤 잠금을 대기하고 있고, 어느 트랜잭션이 가지고 있는지 확인할 수 있음.

InnoDB의 performance_schema를 활용해 스토리지 엔진의 내부 잠금(세마포어)에 대한 모니터링 방법도 추가되었음

### 5.3.1 InnoDB 스토리지 엔진의 잠금
- 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 락 에스컬레이션은 없다 (레코드 락 -> 페이지 락 또는 테이블 락으로 레벨 업)
- 레코드 락 뿐만 아니라 레코드 사이의 간격을 잠그는 갭 락이라는 것이 존재
(사진 첨부 필요) p167

#### 5.3.1.1 레코드 락
- 레코드 자체만을 잠그는 것
- 다른 DBMS와의 차이점은 레코드 자체가 아니라 인덱스의 레코드를 잠근다는 점
    - 인덱스가 하나도 없어도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정
- 레코드 자체를 잠그는 것과 인덱스를 잠그는 것은 중요한 차이를 만들어 냄
- 보조 인덱스를 이용한 변경 작업은 넥스트 키 락, 갭 락을 사용, PK 또는 유니크 인덱스에 의한 변경 작업은 갭은 잠그지 않고 레코드 자체에 대해서만 락을 건다.

#### 5.3.1.2 갭 락
- 레코드 자체가 아니라 인접한 레코드와의 간격만을 잠그는 것
- 레코드 사이에 새로운 레코드가 생성되는 것을 제어하는 것
- 그 자체보다 넥스트 키 락의 일부로 자주 사용 됨

#### 5.3.1.3 넥스트 키 락
- 레코드 락과 갭 락을 합쳐 놓은 형태
- statement 포맷의 바이너리 로그를 사용하는 MySQL 서버에서는 REPEATABLE READ 격리 수준을 사용해야 함
    - 왜지?
- 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 섯버에서 만들어낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적
    - 그러나 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션이 기다리는 일이 자주 발생
    - 따라서 바이너리 로그 포맷을 ROW 형태로 변경하여 넥스트 키 락, 갭 락을 줄이는 것이 좋다. (MySQL 8.0에서는 ROW 포맷이 default)

#### 5.3.1.4 자동 증가 락
- MySQL 5.0 이하 버전
    - auto_increment 컬럼이 사용된 테이블에 동시에 여러 레코드가 insert 되는 경우 내부적으로 auto_increment 락이라고 하는 테이블 수준의 잠금을 사용
    - insert와 replace 쿼리 문장과 같이 새로운 레코드를 저장하는 쿼리에서만 필요함
        - auto_increment 값을 가져오는 순간만 락이 걸렸다가 즉시 해제 -> 대부분 문제가 되지 않음
        - auto_increment 컬럼에 값을 설정하더라도 락을 걸게 됨
- MySQL 5.1 이상 버전
    - innodb_autoinc_lock_mode 라는 시스템 변수를 이용해 락의 작동 방식을 변경
        - 0: 기존과 동일한 방식으로 자동 증가 락을 사용
        - 1: MySQL 서버가 insert 되는 레코드 수를 정확히 예측할 수 있을 때 자동 증가 락 대신 훨씬 가볍고 빠른 래치(뮤텍스)를 이용해 처리
            그러나 insert ... select 와 같이 쿼리를 실행하기 전에 건수를 예측할 수 없다면 기존과 같은 방식 사용
            대량 insert 시에는 한 번에 자동 증가 값을 할당 받아서 사용하기 떄문에 값이 연속되게 insert -> 연속 모드 (consecutive mode)
            대신 값이 남아서 사용하지 않으면 폐기
        - 2: 절대 자동 증가 락을 걸지 않고 래치만 사용
            insert ... select 같은 형태도 연속된 자동 증가 값을 보장하지 않음 -> 인터리빙 모드 (interleaved mode)
            대량 insert 중간에 다른 커넥션 insert도 실행가능하여 동시 처리 성능이 높아짐
            -> 이때는 자동 증가 기능은 유니크한 값이 생성되는 것만을 보장하기 때문에 statement 포맷의 바이너리 로그로 복제하는 경우 자동 증가 값이 소스와 다를 수 있음
    - 자동 증가 값이 절대 줄어들지 않는 이유는 auto_increment 잠금을 최소화하기 위해서. insert가 실패해도 증가된 값은 그대로 남는다

### 5.3.2 인덱스와 잠금
- 레코드 락 : 인덱스를 잠그는 방식으로 처리 -> 변경할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 함
    - 인덱스가 없다면 테이블을 풀 스캔하면서 모든 레코드를 잠근다. 따라서 인덱스 설계가 중요하다

### 5.3.3 레코드 수준의 자금 확인 및 해제