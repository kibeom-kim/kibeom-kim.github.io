---
title: 개발자를 위한 레디스 4장
date: 2025-05-09
update: 2025-05-09
tags: 
	- redis
---

# Redis 자료 구조 활용 사례# Redis 자료 구조 활용 사례

> 레디스의 자료구조를 활용하면 복잡한 어플리케이션의 연산을 자료구조의 특징으로 대체할 수 있다.

### 리더보드 (Sorted Set)
- 리더보드에는 두 가지 유형
	- 절대적 리더보드: 서비스의 모든 유저를 정렬시켜 상위권의 목록만을 표시하는 방법
	- 상대적 리더보드: 사용자마다 다른 데이터를 보여줌
- 요건
	- 기본적으로 사용자의 스코어를 기반으로 데이터를 정렬
	- 실시간으로 반영되어 사용자가 자신의 순위 상승을  바로 확인할 수 있어야 함
- 레디스의 sorted set 은 저장될 때부터 정렬됨 -> 데이터를 읽을 때 정렬하지 않아도 됨
- 구현
	1. 월별 리더보드, 주간 리더보드, 일별 리더보드의 구현이 가능
	2. 20250510의 일별 리더보드는 다음과 같이 구성
	3. daily_score:20250510을 키로 설정
	4. value로는 score : value = user_score: user_id로.
		1. ZRANGE daily_score:20250510 0 -1 withscores 로 전체 순위 조회 가능 (오름차순)
		2. ZREVRANGE daily_score:20250510 0 -1 withscores 로 전체 순위 조회 가능 (내림차순)
	5. `ZUNIONSTORE` 연산을 통해 리더보드의 합산을 수행 가능
		1. 지정한 키에 연결된 각 아이템의 스코어를 합산하는 커맨드
		2. `ZUNIONSTORE` <생성할 키 이름> <합산할 키 개수> <합산할 키> ...
		3. 합칠 때 가중치도 부여할 수 있음
			1. `ZUNIONSTORE` weekly-score:2208-03 3 daily-score220815 daily-score220816 daily-score220817 weights 1 2 1 

#### 추가 고려사항
1. 주간 리더보드의 합산을 매주 1회 갱신이 아니라, 실시간으로 제공해야 한다면..?
2. 주간리더보드를 하나 만들고 그 리더보드에 비동기로 업데이트를 치는 방식
3. 주간리더보드의 결과를 캐싱을 해두고,, 캐시를 주기적으로 업데이트한다.
4. 캐시 업데이트의 주기마다 worker redis에서 읽기 연산을 돌려서 캐시를 최신화한다.
5. 구조의 개선을 통해서 가능한 부분도 있다.
6. 누적 점수를 매일 계산한다. 계산된 누적 점수는 하루동안은 유지된다.
7. TOP-N 만을 유지하고 누적 처리를 한다.
8. 샤딩하여 논리적으로 계산한다.
9. 유저별로 샤드를 나누어서 다른 키의 zset에 저장하고, TOP-10만 뽑아서 어플리케이션에서 논리적으로 계산한다.
10. TOP-N을 유지한다면 아주 효율적인 방식이다.
11. 비동기로 갱신하며 worker가 stream을 받아서 주간보드를 갱신한다.
12. 클러스터 구성을 통해서 트래픽 해소가 가능할까 ?
13. primary-replica 설정을 통해서 해결이 가능하다.
14. 무거운 읽기 연산용 replica / 사용자 읽기 연산용 replica 구성
15. 실시간 데이터 + 쓰기용으로 primary를 사용

### 최근 검색 기록 (Sorted Set)
- 요건
	- 검색한 시점을 기준으로 소팅
	- 오래된 검색 기록을 삭제하는 작업이 필요할 수 있음
- 구현
	1. 유저별 최근 검색 기록을 시간을 스코어로 사용함
		1. 시간별 정렬이 가능
	2. 검색하면 ZADD를 활용해서 갱신
	3. 읽기 전에 인덱스를 활용해서 최대 갯수를 이외의 검색어는 제거한다
		1. 예) 최대 5개인 경우 -6 인덱스의 데이터를 삭제 -> 5개 이하인 경우를 고려하지 않아도 됨
		2. `ZREMRANGEBYRANK` search-keyword -6 -6

### 게시물 태그 기능 (Set)
- 요건
	- 특정 게시물이 어떤 태그와 연관돼 있는지 확인
	- 특정 태그를 포함한 게시물들만 확인할 수 있어야 함
	- -> 포스트를 기준으로 하는 set, 태그를 기준으로 하는 set 필요
- 구현
	- 
	```shell
	> SADD post:53:tags IT MySQL DataStore
	> SADD tag:DataStore:posts 53
	> SADD tag:IT:posts 53
	> SADD tag:MySQL:posts 53
	```
	- SINTER 연산을 통해서 원하는 tag를 동시에 갖고 있는 post를 뽑는 등의 연산이 가능

#### 고려사항
1. 너무 많은 post가 존재한다면 post의 번호 기준으로 샤딩하여 저장하자

### 랜덤 추출
1. O(1)의 시간 복잡도로 랜덤 추출이 가능
2. `RANDOMKEY`는 전체 키 중하나를 무작위로 반환
	1. hash, set, sorted set 등 각 키들 중 랜덤 값을 추출할 수 있음
	2. count  옵션을 양수로 하면 중복되지 않은 데이터가 반환 / 음수로 설정하면 중복될 수 있음
	
    ```shell
	> HRANDFIELD user:hash 2
	1) Id:4615
	2) Id:124

	> HRANDFIELD user:hash -2
	1) Id:4615
	2) Id:4615
	```

## 레디스에서의 다양한 카운팅 방법
### 좋아요
1. 댓글의 id 기준으로 set을 구성하고, 좋아요를 누른 유저의 id를 set의 member로 추가
2. 반대로 유저 기준으로 set을 구성하고 유저 set에 좋아요를 누른 댓글의 번호를 저장
3. 이때 둘 다 샤딩을 하여 분산 저장
 
### 채널의 안 읽은 메시지 수 카운팅
1. 메신저 채널당 안 읽은 메시지의 수를 카운팅 해야 함
2. 유저당 하나의 hash를 갖고 이 hash의 key는 채널방, value는 읽지 않은 메시지의 개수를 저장
3. 인메모리 redis에 저장하고 유저가 읽으면 value의 값을 감소시킴

#### 추가 고려사항
1. 채널당 속해있는 유저는 서버의 DB로 관리
2. 어떤 유저가 글을 보내고 글을 지운다면, 채널방에 속해있는 유저의 목록을 갖고 소켓 통신을 하고 있는 단말 어플리케이션 프로세스에 카운터 다운 통신을 시도


### DAU (bitmap)
1. bitmap은 string의 최대 길이인 512MB의 데이터를 저장할 수 있음
2. bit로 계산하면 거의 1000만개의 bit
3. 따라서 1000만 유저의 체크로직이 가능 (유저의 id가 0이상의 정수 단위여야함)
4. dau는 실시간일 필요는 없으니 비동기 구조로 bitmap의 bit를 세팅
5. 해당 일자의 bitmap의 bitcount를 활용하여 방문자 수를 구할 수 있음.
6. 누가 방문했는지는 application 단에서 계산이 가능하다. bit -> int 연산으로 가능
7. 출석 이벤트의 경우도 서로 다른 일자의 bitmap의 공통된 비트를 구하여 bitop and 연산으로 계산 가능

### 미터링 서비스 (Hyperloglog)

- 미터링 서비스는 사용자가 얼마나 서비스를 사용했는지를 정확하게 측정해야 함
	- 높은 처리량과 낮은 대기 시간이 요구됨
	- 예를 들어서 로그를 보내고 집계하여 통계를 제공하는 서비스가 있고 이 서비스는 사용자가 얼만큼의 로그를 누적했는지를 토대로 과금한다고 가정
	- 이 경우 과금 정도를 측정하기 위해선 로그를 몇 개 누적했는지를 추적해야 함
	- 하지만 count 자체는 비용이 큰 연산이니, Hyperloglog를 사용해서 count 전용 set을 만들어 여기에 로그를 누적할때마다 로그의 고유값(해시)를 넣어준다고 가정한다면 과금 정도를 간단하게 측정할 수 있음
- Hyperloglog는 set과 비슷하지만 저장되는 용량이 12KB로 고정되기 때문에 공간 효율적임

## 위치 기반 어플리케이션 개발
### 위치 데이터란
- 주로 경도와 위도 쌍으로 표현됨
- 사용자의 위치가 실시간으로 변할 때 신속하게 저장하고, 처리할 수 있는 저장소는 아래 기능이 요구됨
	- 사용자의 현재 위치 파악
	- 실시간 변동 위치 업데이트
	- 위치를 기준으로 근처의 장소 검색

### 레디스에서의 위치 데이터
- geo 자료 구조를 이용해 공간 정보 데이터를 처리 가능
- 관계형 DB를 이용할 시 데이터 저장만 하고 가공 처리는 저장소 외부에서 이루어져야 함
- 레디스를 활용하면 저장뿐만 아니라 실시간 위치 연산을 직접 수행할 수 있음
	- geo set과 pub/sub 기능을 함께 사용하면 특정 맛집에서 이벤트를 발생시킬 때 근처 위치의 사용자에게 알림 보내기 가능함
- 내부적으로 sorted set 구조로 저장됨

```shell
> GEOADD restaurant 50.123414 14.14321 ramen

> GEOPOS restaurant remen
	1) 50.123414
	2) 14.14321

// 직접 경도와 위도를 지정하여 반경 내의 데이터 검색 가능
// fromember 옵션을 이용하면 직접 입력하지 않고도 원하는 데이터 조회 가능
> GEOSEARCH restaurant fromlonlat 50.123414 14.14321 byradius 1 km 
	1) ramen
```