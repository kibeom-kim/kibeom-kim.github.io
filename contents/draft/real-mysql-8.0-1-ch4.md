---
title: Real MySQL 8.0 1권 - 04 아키텍처
date: 2025-04-02
update: 2025-04-02
tags: 
    - mysql8.0
---

## MySQL 엔진 아키텍쳐
MySQL 서버는 MySQL 엔진과 스토리지 엔진으로 구분할 수 있다.
MySQL 엔진은 클라이언트의 접속 및 쿼리 요청을 처리하는 커텍션 핸들러와 SQL파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 주를 이룬다.
ANSI SQL 문법을 지원하여 표준 문법에 따라 작성된 쿼리도 실행될 수 있다.

MySQL 엔진은 요청된 SQL문장을 분석하거나 최적화하는 작업을 수행한다.
스토리지 엔진은 실제 데이터를 디스크 스토리지에 저장하거나 읽어오는 작업을 전담한다.

`CREATE TABLE test_table(fd1 INT, fd2 INT) ENGINE=INNODB;`

위와 같이 스토리지 엔진을 지정할 수 있으며 지정된 스토리지 엔진이 모든 읽기 작업, 변경 작업을 수행한다.

## 핸들러 API
MySQL 에진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기를 요청해야하고 이것을 핸들러 요청이라고 한다. 이때 사용되는 API를 핸들러 API라고 한다.

`SHOW GLOBAL STATUS LIKE 'Handler%';  // 얼마나 많은 데이터 작업이 있었는지 확인할 수 있다.`

## MySQL 스레딩 구조
MySQL 서버는 스레드 기반으로 작동하며 포그라운드 스레드와 백그라운드 스레드로 구분할 수 있다.

// MySQL 서버에서 실행 중인 스레드의 목록을 performance_schema.threads 테이블을 통해 확인할 수 있다.
// type: foreground, background

select thread_id, name, type, processlist_user, processlist_host
from performance_schema.threads
order by type, thread_id;
백그라운드 프로세스의 개수는 MySQL 서버 설정에 따라 다르며, 동일한 이름의 스레드가 2개 이상 보이는 것은 여러 스레드가 동일 작업을 병렬로 처리하는 경우이다.

### 포어그라운드 스레드
최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재하며 사용자가 작업을 마치고 커넥션을 종료하면 스레드는 다시 스레드 캐시로 되돌아 간다. 스레드 캐시에 유지할 수 있는 최대 스레드 개수는 thread_cache_size 라는 시스템 변수로 제어하며 이미 최대치인 경우 스레드 캐시에 넣지 않고 스레드를 종료시킨다.

데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며 없는 경우 직접 디스크의 데이터나 인덱스 파일로부터 읽어와서 작업을 처리한다.
MyISAM 테이블은 디스크 쓰기 작업까지 처리하지만, InnoDB 테이블은 데이터 버퍼나 캐시까지만 기록하고, 버퍼로부터 디스크까지는 백그라운드 스레드가 처리한다.

### 백그라운드 스레드
MyISAM은 별로 해당 사항이 없지만, InnoDB는 여러 작업이 백그라운드로 처리된다.

Insert Buffer를 병합하는 스레드
로그를 디스크로 기록하는 스레드 (Log thread)
InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드 (Write thread)
데이터를 버퍼로 읽어 오는 스레드
잠금이나 데드락을 모니터링하는 스레드
쓰기 스레드는 일반적인 내장 디스크를 사용할 때는 2-4개 정도로 지정하고, DAS나 SAN과 같은 스토리지(?)를 사용할 때는 디스크를 최적으로 사용할 수 있도록 충분히 설정하는 것이 좋다. (innodb_write_io_threads, innodb_read_io_threads 변수 사용)

사용자의 요청 중 쓰기는 지연되어 처리될 수 있으나 읽기는 그렇지 않다. 따라서 일반적인 상용 DBMS에서는 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 있으며 InnoDB도 마찬가지다. 그러나 MyISAM은 사용자 스레드가 직접 쓰기 작업까지 처리하는데 이유는 일반적은 쿼리는 쓰기 버퍼링 기능을 사용할 수 없기 때문이다.

## 메모리 할당 및 사용 구조
MySQL에서 사용되는 메모리 공간은 크게 글로벌 영역과 로컬 메모리 영여긍로 구분할 수 있다.
글로벌 메모리 영역의 모든 메모리 공간은 MySQL 서버가 시작하면서 OS로부터 할당된다.

글로벌 메모리 영역은 클라이언트 스레드 수와 무관하게 하나의 메모리 공간만 할당된다. 여러 개가 할당되더라도 모든 스레드에 의해 공유된다.
대표적인 글로벌 메모리 영역이다.

- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

로컬 메모리 영역은 MySQL 서버 상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역이다. 클라이언트 스레드가 사용하는 공간이라 클라이언트 메모리 영역이라고도 한다. 클라이언트와 MySQL 서버와의 커넥션을 세션이라고 하기 때문에 세션 메모리 영역이라고도 한다.
이는 스레드 별로 독립적으로 할당되며 절대 공유되지 않는다.

로컬 메모리 영역은 쿼리의 용도에 따라서 MySQL이 공간을 할당하지 않을 수도 있다. 그리고 커넥션이 열려있는 동안 계속 할당된 상태로 남아 있는 공간(커넥션 버퍼나 결과 버퍼)도 있고, 쿼리를 실행하는 순간에만 할당했다가 다시 해제하는 공간(소트 버퍼나 조인 버퍼)도 있다.

대표적인 로컬 메모리 영역이다.

- 정렬 버퍼
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼

## 플로그인 스토리지 엔진 모델
MySQL의 독특한 구조 중 대표적인 것이다. 스토리지 엔진, 검색어 파서, 사용자 인증 등도 플러그인으로 구현되어 제공된다.

MySQL에서 쿼리가 실행되는 과정은 대부분 MySQL 엔진에서 처리되고 (SQL 파서 <-> SQL 옵티마이저 <-> SQl 실행기), 데이터 읽기/쓰기 작업만 스토리지 엔진에서 처리된다. 새로운 스토리지 엔진을 만들어도 전체가 아니라 일부분만 담당하게 된다는 것이다.

MySQL에서 다른 스토리지 엔진을 사용하는 테이블에 대해 쿼리를 실행해도 MySQL의 처리내용은 동일하며 데이터 읽기/쓰기 영역의 차이만 있다. 실질적인 group by나 order by 등 복잡한 처리는 MySQL 엔진의 처리 영역인 쿼리 실행기에서 처리된다. 그렇지만 스토리지 엔진에 따라서 데이터 읽기/쓰기 작업 처리 방식이 달라진다.

## 컴포넌트
MySQL 8.0부터는 플로그인 아키텍처의 단점을 보완하여 컴포넌트 아키텍처가 지원된다.

플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없음
플러그인은 MySQL 서버의 변수나 함수를 직접 호출하여 안전하지 않음
플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어려움

## 쿼리 실행 구조
- MySQL 엔진
    - 쿼리 파서
        - 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업
        - 기본적인 문법 오류가 발견되고 사용자에게 오류 메세지를 전달
    - 전처리기
        - 파서 트리를 기반으로 쿼리 문장에 구조적인 문제가 있는지 확인
            - 테이블 이름이나 컬럼 이름, 내장 함수와 같은 개체를 매핑해 존재 여부와 객체의 접근 권한 등을 확인하는 과정
            - 존재하지 않거나 권한이 없는 개체의 토큰은 이 단계에서 걸러짐
    - 옵티마이저
        - DBMS의 두뇌 역할 (쿼리 변환, 비용 최적화, 실행 계획 수립)
    - 실행 엔진
        - 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러의 요청의 입력으로 연결하는 역할을 수행
- 스토리지 엔진 : 핸들러
    - MySQL 서버의 가장 밑단에서 실행 엔진의 요청에 따라 데이터를 디스크에 저장, 조회하는 역할
     - InnoDB 테이블을 조작하는 경우 핸들러는 InnoDB가 됨

## 쿼리 캐시
- SQL 실행 결과를 메모리에 캐시하고 동일 쿼리가 실행되면 테이블을 읽지 않고 즉시 결과를 반환하기 때문에 매우 빠른 성능
- 테이블의 데이터가 변경되면 캐시된 결과 중 관련된 것들을 모두 삭제해야 했고 이는 동시 처리 성능 저하르 유발 => MySQL 8.0에서 제거됨
- 스레드 풀
- 엔터프라이즈 버전에서는 제공하지만 커뮤니티 버전에서는 지원하지 않음
- 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많아도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적
    - 실제 서비스에서 눈에 띄는 성능 향상을 보여주는 경우는 드물다
        - 스케줄링에서 CPU 시간을 확보하지 못하면 오히려 쿼리 처리가 더 느려질 수 있음
- 모든 스레드가 일을 하고 있다면 기다릴지 새로운 스레드를 추가할지 판단해야 함
    - thread_pool_stall_limit 의 밀리초 동안 작업이 끝나지 않으면 새로운 스레드 추가
        - 스레드 풀의 스레드 개수는 thread_pool_max_threads 를 넘을 수 없음

## 4.1.9 스레드 풀
사용자의 요청을 처리하는 스레드 개수를 줄여서 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있도록 서버 자원 소모를 줄이는 것이 목적.
스레드 풀이 실 서비스에서 성능 향상을 보여준 경우는 드물지만 적절히 유도하여 제한된 수의 cpu만으로 처리하도록 한다면 cpu 프로세서 친화도를 높이고, 운영체제 입장에서는 불필요한 컨텍스트 스위치를 줄일 수 있다.

스레드 그룹의 모든 스레드가 일을 처리하고 있다면 새로운 작업 스레드를 추가할지, 기존 작업 스레드를 기다릴지 여부를 판단해야 한다.
thread_pool_stall_limit 시스템 변수에 정의된 밀리초만큼 기다리고 기존 스레드가 작업을 완료하지 못한다면 새로운 스레드를 생성하여 스레드 그룹에 추가한다. -> thread_pool_stall_limit을 0에 가깝게 설정한다면 스레드 풀을 사용하지 않는 편이 나을 것이다.
이때 전체 스레드 풀에 있는 스레드의 개수는 thread_pool_max_threads 시스템 변수에 설정된 개수를 넘어설 수 없다.

## 4.1.10 트랜잭션 지원 메타데이터
테이블의 구조 정보와 스토어드 프로그램 등의 정보를 데이터 딕셔너리 또는 메타 데이터라고 함.
파일 기반의 메타데이터는 트랜잭션을 지원하지 않아 일관되지 않은 상태로 남는 문제가 있음 -> 테이블이 깨졌다.

8.0부터는 테이블의 구조 정보나 스톧어드 프로그램의 코드 관련 정보를 모두 innodb의 테이블에 저장하도록 개선됐다.
mysql 서버가 작동하는데 기본적으로 필요한 테이블들을 묶어서 시스템 테이블이라고 하는데, 모두 InnoDB 스토리지 엔진을 사용하도록 개선. 시스템 테이블과 메타데이터를 모아 mysql DB에 저장. mysql db는 통째로 mysql.ibd라는 이름의 테이블스페이스에 저장됨.

테이블이 MyISAM이나 CSV 등과 같은 스토리지 엔진의 메타 정보는 여전히 저장할 공간이 필요. SDI 파일을 이용. InnoDB 테이블들의 구조도 SDI 파일로 변환할 수 있다.

--- 

## 4.2 InnoDB 스토리지 엔진 아키텍처
거의 유일하게 레코드 기반의 잠금을 제공하여 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

### 4.2.1 프라이머리 키에 의한 클러스터링
모든 테이블은 기본적으로 PK를 기준으로 클러스터링 되어 저장된다. -> pk 순서대로 디스크에 저장된다는 뜻이며 모든 세컨더리 인덱스는 레코드의 주소 대신 pk의 값을 논리적인 주소로 사용. pk 를 이용한 레인지 스캔은 빠르게 처리가능

MyISAM에서는 클러스터링 키를 지원하지 않는다. 따라서 pk와 세컨더리 키의 차이가 없으며 단지 유니크 제약 정도만이 차이다.

### 4.2.2 외래 키 지원
InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 MyISAM이나 MEMORY 테이블에서는 사용할 수 없음

외래 키는 부모테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하고, 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하여 자금이 여러 테입르로 전파, 그로 인한 데드락이 발생할 때가 많으니 주의 필요

### 4.2.3 MVCC (Multi Version Concurrency Control)
일반적으로 레코드 기반 잠금을 제공하는 DBMS에서 제공하는 기능
잠금을 사용하지 않는 일관된 읽기를 제공하는 것이 목적.
InnoDB는 언두로그를 활용하여 기능을 구현
멀티 버전 -> 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 뜻

메모리 (InnoDB 버퍼 풀, 언두 로그 존재)
-> update 시 버퍼 풀에 새로운 값이 commit 여부와 상관없이 업데이트 됨. 기존 값은 언두 로그에 있다.
이때 격리 수준에 따라서 어느 곳에 있는 데이터를 조회할지 결정된다.
read_uncommitted 라면 버퍼 풀의 값을 조회하여 응답. read_committed거나 그 이상인 경우에는 언두 로그의 데이터를 반환
이러한 과정을 dbms에서는 mvcc라고 표현
=> 하나의 레코드에 대해 2개의 버전이 유지되고, 필요에 의해 어느 데이터가 보여질지 달라지는 구조.

### 4.2.4 잠금 없는 일관된 읽기

